# -*- coding: utf-8 -*-
"""자율연구.ipynb의 사본

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1icTwPRp-SdxZfuPMG5G_rK6-MwzsV2dw
"""

def heuristic_algorithm_1(data, indices, revenue, max_operation_time=65):
    # 데이터에 노드 '1' 추가 (이미 포함되어 있지 않다면)

    # 주문 수 (0번 인덱스는 placeholder)
    num_orders = len(revenue) - 1

    # Step 1: 각 주문에 대한 총 이동 시간과 단위 시간당 수익 계산
    order_info = []
    for k in range(1, num_orders + 1):
        mk_index = indices.index('m' + str(k))
        # 주문 k의 총 이동 시간 계산 (t_{0,mk} + t_{mk,1})
        travel_time_k = data[0][mk_index-1] + data[mk_index][mk_index+num_orders-1]
        # 단위 시간당 수익 계산
        profit_per_time_k = revenue[k] / travel_time_k
        order_info.append([k, profit_per_time_k])

    # Step 2: 단위 시간당 수익이 큰 순서대로 주문 정렬
    order_info.sort(key=lambda x: x[1], reverse=True)

    # Step 3: 모든 주문 선택
    selected_orders = [info[0] for info in order_info]

    # 초기화 변수들
    best_profit = 0
    optimal_orders = []
    optimal_route = []
    total_travel_time = 0

    # Step 4-6: 총 이동 시간이 최대 운행 시간을 초과하면 마지막 주문을 제거하며 반복
    while True:
        # 선택된 주문에 따라 경로 구성
        route = [0]  # 시작 노드 '0'의 인덱스는 0
        for order in selected_orders:
            mk_index = indices.index('m' + str(order))
            ck_index = indices.index('c' + str(order))
            route.extend([mk_index, ck_index])
        route.append(2*num_orders+1)  # 종료 노드 '1'

        # 경로의 총 이동 시간 계산
        total_travel_time = 0
        for i in range(len(route) - 1):
            from_index = route[i]
            to_index = route[i + 1]
            total_travel_time += data[from_index][to_index-1]

        # 총 이동 시간이 최대 운행 시간 이내인지 확인
        if total_travel_time <= max_operation_time:
            # 최적 주문 조합과 경로 저장
            optimal_orders = selected_orders.copy()
            optimal_route = [indices[idx] for idx in route]
            best_profit = sum(revenue[order] for order in selected_orders)
            break
        else:
            # 마지막 주문 제거 후 다시 시도
            if selected_orders:
                selected_orders.pop()
            else:
                break  # 더 이상 선택할 주문이 없음

    # Step 7: 결과 출력
    print("최적주문조합 (Optimal Order Set):", optimal_orders)
    print("최적경로 (Optimal Route):", ' -> '.join(optimal_route))
    print("총이동시간 (Total Travel Time):", total_travel_time)
    print("최적수익 (Optimal Profit):", best_profit)
    print("수익*10-시간:", best_profit*10 - total_travel_time)
    return best_profit*10 - total_travel_time


def heuristic_algorithm_2(data, indices, revenue, max_operation_time=65):

    # 주문 수 (0번 인덱스는 placeholder)
    num_orders = len(revenue) - 1

    # 노드 이름을 인덱스로 매핑
    # 딕셔너리를 사용하지 않고 리스트의 인덱스를 사용
    # indices 리스트에서 인덱스 값을 직접 사용

    # Step 1: 각 주문에 대한 총 이동 시간과 단위 시간당 수익 계산
    order_info = []
    for k in range(1, num_orders + 1):
        mk_index = indices.index('m' + str(k))
        ck_index = indices.index('c' + str(k))
        # 주문 k의 총 이동 시간 계산 (t_{0,mk} + t_{mk,ck})
        travel_time_k = data[0][mk_index-1] + data[mk_index][ck_index-1]
        # 단위 시간당 수익 계산
        profit_per_time_k = revenue[k] / travel_time_k
        order_info.append([k, profit_per_time_k])

    # Step 2: 단위 시간당 수익이 큰 순서대로 주문 정렬
    order_info.sort(key=lambda x: x[1], reverse=True)

    # Step 3: 모든 주문 선택
    selected_orders = [info[0] for info in order_info]

    # 초기화 변수들
    best_profit = 0
    optimal_orders = []
    optimal_route = []
    total_travel_time = 0

    # Step 4-6: 총 이동 시간이 최대 운행 시간을 초과하면 마지막 주문을 제거하며 반복
    while selected_orders:
        # 선택된 주문의 픽업 및 배송 노드 리스트 생성
        pickup_nodes = []
        delivery_nodes = []
        for order in selected_orders:
            mk_index = indices.index('m' + str(order))
            ck_index = indices.index('c' + str(order))
            pickup_nodes.append(mk_index)
            delivery_nodes.append(ck_index)


        # 경로 탐색: 현재 위치에서 가장 가까운 노드로 이동 (그리디 알고리즘)
        unvisited_pickups = pickup_nodes.copy()
        unvisited_deliveries = delivery_nodes.copy()
        visited_nodes = [0]  # 시작 노드 '0'의 인덱스는 0
        current_node = 0
        route = [indices[current_node]]  # 경로에 노드 이름 추가
        while unvisited_pickups or unvisited_deliveries:
            # 방문 가능한 다음 노드 찾기
            candidates = []
            # 픽업 노드 중 아직 방문하지 않은 노드 추가
            for node in unvisited_pickups:
                candidates.append(node)
            # 배송 노드 중 픽업이 완료된 노드 추가
            for node in unvisited_deliveries:
                order_idx = delivery_nodes.index(node)
                mk_index = pickup_nodes[order_idx]
                if mk_index in visited_nodes:
                    candidates.append(node)

            # 다음 방문할 노드 선택
            min_distance = float('inf')
            next_node = None
            for node in candidates:
                distance = data[current_node][node-1]
                if distance <= min_distance:
                    min_distance = distance
                    next_node = node
            # 노드 이동 및 상태 업데이트
            total_travel_time += data[current_node][next_node-1]
            current_node = next_node
            visited_nodes.append(current_node)
            route.append(indices[current_node])

            if current_node in unvisited_pickups:
                unvisited_pickups.remove(current_node)
            if current_node in unvisited_deliveries:
                unvisited_deliveries.remove(current_node)
        # 마지막으로 종료 노드 '1'으로 이동
        end_index = indices.index('1')
        total_travel_time += data[current_node][end_index-1]
        route.append('1')


        # 총 이동 시간이 최대 운행 시간 이내인지 확인
        if total_travel_time <= max_operation_time:#그리디를... 이딴식으로 설명하면..... 최소한 등호 조건 넣었다고 설명해야 하는거 아닌가
            # 최적 주문 조합과 경로 저장
            optimal_orders = selected_orders.copy()
            optimal_route = route.copy()
            best_profit = sum(revenue[order] for order in selected_orders)
            break
        else:
            # 마지막 주문 제거 후 다시 시도
            selected_orders.pop()
            total_travel_time = 0  # 총 이동 시간 초기화

    # Step 7: 결과 출력
    print("최적주문조합 (Optimal Order Set):", optimal_orders)
    print("최적경로 (Optimal Route):", ' -> '.join(optimal_route))
    print("총이동시간 (Total Travel Time):", total_travel_time)
    print("최적수익 (Optimal Profit):", best_profit)
    print("수익*10-시간:", best_profit * 10 - total_travel_time)
    return best_profit * 10 - total_travel_time


def heuristic_algorithm_3(data, indices, revenue, max_operation_time=65):

    num_orders = len(revenue) - 1  # 주문은 1번부터 시작

    # Step 1: 초기화
    optimal_orders = []
    optimal_route = []
    optimal_profit = 0

    # 모든 가능한 주문 조합 생성 (부분집합)
    from itertools import combinations

    # 주문 리스트 (1번부터 num_orders까지)
    order_list = list(range(1, num_orders + 1))

    # 모든 가능한 주문 조합에 대하여 반복
    for r in range(1, num_orders + 1):
        for selected_orders in combinations(order_list, r):
            selected_orders = list(selected_orders)

            # Step 3: 선택된 주문 조합의 수익 계산
            total_profit = sum(revenue[order] for order in selected_orders)

            # Step 4: 선택된 주문 조합 수익이 현재 최적 수익보다 큰 경우
            if total_profit >= optimal_profit:
                # Step 5: 그리디 경로 탐색 및 총 이동 시간 계산

                # 픽업 및 배송 노드 인덱스 생성
                pickup_nodes = [indices.index('m' + str(order)) for order in selected_orders]
                delivery_nodes = [indices.index('c' + str(order)) for order in selected_orders]

                # 그리디 알고리즘을 사용한 경로 탐색
                unvisited_pickups = pickup_nodes.copy()
                unvisited_deliveries = delivery_nodes.copy()
                visited_nodes = [0]  # 시작 노드 '0'
                current_node = 0
                route = [indices[current_node]]
                total_travel_time = 0

                while unvisited_pickups or unvisited_deliveries:
                    candidates = []
                    # 방문하지 않은 픽업 노드 추가
                    candidates.extend(unvisited_pickups)
                    # 픽업이 완료된 배송 노드 추가
                    for node in unvisited_deliveries:
                        order_idx = delivery_nodes.index(node)
                        mk_index = pickup_nodes[order_idx]
                        if mk_index in visited_nodes:
                            candidates.append(node)
                    # 후보 노드가 없는 경우 종료
                    if not candidates:
                        break
                    # 가장 가까운 노드 선택
                    min_distance = float('inf')
                    next_node = None
                    for node in candidates:
                        distance = data[current_node][node-1]
                        if distance < min_distance:
                            min_distance = distance
                            next_node = node
                    # 노드 이동 및 상태 업데이트
                    a=data[current_node][next_node-1]
                    total_travel_time += a

                    current_node = next_node
                    visited_nodes.append(current_node)
                    route.append(indices[current_node])
                    if current_node in unvisited_pickups:
                        unvisited_pickups.remove(current_node)
                    if current_node in unvisited_deliveries:
                        unvisited_deliveries.remove(current_node)

                # 종료 노드 '1'으로 이동
                end_index = indices.index('1')
                total_travel_time += data[current_node][end_index-1]
                route.append('1')


                # Step 6: 총 이동 시간이 최대 운행 시간 이내인 경우
                if total_travel_time <= max_operation_time:


                    # Step 7: 최적 주문 조합 및 경로 업데이트

                    optimal_orders = selected_orders.copy()
                    optimal_route = route.copy()
                    optimal_profit = total_profit
                    optimal_travel_time=total_travel_time

            # Step 8: 다음 주문 조합으로 이동

    # 결과 출력
    print("최적주문조합 (Optimal Order Set):", optimal_orders)
    print("최적경로 (Optimal Route):", ' -> '.join(optimal_route))
    print("총이동시간 (Total Travel Time):", optimal_travel_time)
    print("최적수익 (Optimal Profit):", optimal_profit)
    print("수익*10-시간:", optimal_profit * 10 - total_travel_time)
    return optimal_profit * 10 - total_travel_time
